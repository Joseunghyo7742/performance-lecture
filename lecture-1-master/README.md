bb# 1장 블로그 서비스 최적화

### 이 장에서 최적화 기법
- 이미지 사이즈 최적화
  > 이미지를 적정한 사이즈로 사용해야 한다. 너무 작으면 화질 저하, 너무 크면 네트워크 트래픽의 증가로 로딩속도가 느려짐. 
- 코드 분할
  > SPA의 특성상 모든 리액트 코드는 하나의 js로 번들링 되므로 쓰지 않는 코드도 첫 로딩 시에 포함되어 무거워짐. 따라서 당장 필요없는 코드는 스플리팅하여 필요 시점에 쓰도록 분할. 
- 텍스트 압축
  > 웹페이지 접속 시 다양한 리소스(HTML, CSS, js 등)을 받는데 서버에서 미리 압축이 가능함. 압축 시 본 사이즈보다 작은 사이즈로 다운로드 할 수 있어서 웹페이지 로드가 빨라짐.
- 병목 코드 최적화 
  > 특정 js 코드 때문에 서비스가 느리게 다운되거나 실행되는 경우가 있음. 이런 현상을 만드는 코드를 '병목 코드' 라고 함. 이 병목코드를 최적화 해보자.

### 예제 프로젝트 안 열리는 오류
> `npm run start` 해보았으나 열리지 않음
-  node 버전 호환 문제로 node 16버전으로 다운그레이드 해주어야 함.
-  `nvm` 을 사용하여 노드버전을 변경 해주었다. 
    > `nvm` 은 node version manager로 node.js의 도구다. 개발환경에 여러 개의 node 버전을 설치해 상황에 따라 node.js 버전을 변경해가며 사용 할 수 있게 해준다.
- nvm 사용방법
  - nvm 설치 : https://github.com/coreybutler/nvm-windows/releases 에서 `nvm-setup-zip` 다운 
  - `nvm install 16` 으로 node 버전 설치
  - `nvm ls` 로 사용 가능 버전 확인
  - `nvm use 16` 으로 버전 체인지
  - `node -v` 으로 16버전인지 확인

### Lighthouse 검사
- Mode
  - `Navigation` 기본 값으로, 초기 페이지 로딩 시 발생하는 성능 문제를 분석
  - `Timespan` 사용자가 정의한 시간 동안 발생한 성능 문제를 분석
  - `Snapshot` 현재 상태의 성능 문제를 분석
- Categories
  - `Performance`: 웹페이지의 로딩 과정에서 발생하는 성능 문제를 분석
  - `Accessibility`: 서비스의 사용자 접근성 문제를 분석
  - `Best Practices`: 웹사이트의 보안 측면과 웹 개발의 최신 표준에 중점을 두고 분석
  - `SEO`: 검색 엔진에서 얼마나 잘 크롤링되고 검색 결과에 표시되는지 분석
  - `Progressive Web App`: 서비스워커와 오프라인 동작 등, PWA와 관련된 문제를 분석. 

### 웹 바이탈 분석
![alt text](image.png)
1. First Contentful Paint
   > 페이지가 로드될 때 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링하는 데 걸리는 시간. 총점의 10% 가중치를 가짐.
2. Largest Contentful Paint
   > 페이지가 로드될 때 화면 내에 있는 가장 큰 이미지나 텍스트 요소가 렌더링되기까지 걸린 시간. 가중치 25%를 가짐.
3. Total Blocking Time
   > 페이지가 클릭, 입력 등 사용자와 상호작용에 응답하지 않도록 차단된 시간의 총합. 이는 FCP와 TTI 사이 시간 동안 일어남. 메인 스레들르 독점해 다른 동작을 방해하는 작업에 걸린 시간을 총합. 가중치 30% 
4. Cumulative Layout Shift
   > 페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정. 레이아웃 이동은 화면 상에서 요소의 위치나 크기가 순간적으로 변하는 것. 15% 가중치.   
5. Speed Index 
   > 페이지 로드 중 콘텐츠가 시각적으로 표시되는 속도. (skeleton을 적용하면 더 높은 점수 일 수 있다.) 가중치 10%

- 모바일 환경은 비교적 더 느리다. 

### 이미지 최적화 
- Diagnotics 항목을 보면 `Properly size images` 를 볼 수 있다.
    ![alt text](image-1.png)
- 항목에 어떤 이미지가 적절하지 않은 사이즈인지 보여준다. 
- 전체 이미지에 대해 최적화 시 약 3,241.9KiB를 절약할 수 있다. 
- 1 KiB는 2^10 byte로 1024byts. KB는 10^3 = 1,000bytes. 
  
  ![alt text](image-2.png)
- 실제 이미지 사이즈인 Intrinsic size는 1200 * 1200 px이나 렌더 사이즈는 120 * 120px이다.
- 따라서 사이즈를 더 줄여도 된다. 요즘은 같은 공간에 더 많은 픽셀을 그릴 수 있기 때문에 120px의 두 배인 240 * 240px이 적절하다. 
- 이 이미지들은 로컬 API 서버가 넘겨준 데이터이다. Network탭 > articles> Preview에서 데이터 형식을 보면 `unsplash.com` 에서 받아오는 이미지임을 확인할 수 있다.
- 정적 이미지라면 자르면 되지만 API를 통해 받아오는 것은 `Cloudinary`나 `Imgix` 같은 이미지 CDN을 사용해 최적화 한다. 

### 이미지 CDN 
> CDN(Content Delivery Network)는 물리적 거리의 한계를 극복하기 위해 사용자와 가까운 곳에 콘텐츠 서버를 두는 기술이다. 서버에 있는 리소스를 사용자와 가까운 서버에 캐싱해두어 다운로드 시간을 단축시키는 것.

> 이미지 CDN은 이미지에 튻화된 CDN으로 '__CDN 기능 + 이미지를 특정 형태로 가공해 전달해주는 기능'__ 이 있다.

- `http://cdn.image.com?src=[img src]&width=240&height=240` 이미지 cdn 서버의 주소에 쿼리스트링으로 가져올 이미지 주소, 원하는 형태를 명시해줄 수 있다.
- 위 방법도 있고, imgix와 같은 cdn 솔루션도 있다. 이 예제에서는 unsplash가 이미지 cdn역할을 하고 있다.
- getParametersForUnsplash 함수로 전달되는 width와 height를 수정해서 최적화

**변경후**
![alt text](image-3.png)
- TBT, SI, LCP등 점수가 많이 상향됨
  
### 병목 코드 최적화 
![alt text](image-5.png)
- javascript execution time: JS 파싱, 컴파일 및 실행에 소요되는 시간을 줄여보자. 더 작은 JS 페이로드를 제공해 문제를 해결하자. 
- `js/1.chunk.js`를 확인해보면 939ms동안 실행된다. 
- Performance 패널을 통해 메인 스레드 작업을 상세히 살펴보아 왜 그랬는지 알아보자
- Performance> 새로고침 아이콘(ctrl+shift+E). 

![alt text](image-6.png)
1. CPU 차트: 시간에 따라 CPU가 어떤 작업에 리소스를 사용하고 있는지 비율로 보여줌. 
   - 자바스크립트=노랑/ 렌더링,레이아웃=보라/ 페인팅=초록/ 기타 시스템= 회색
   - 빨간색 선은 병목 발생 지점. 
2. Network 차트
   - CPU 밑에 막대 형태로 표기. 위쪽에 진한 막대는 우선순위가 높은 네트워크 리소스 
   - 왼쪽 회색선: 초기 연결 시간
   - 막대의 옅은 색: 요청을 보낸 시점부터 응답을 기다리는 시점까지 시간 (TTFB)
   - 막대의 짙은 색: 콘텐츠 다운로드 시간
   - 오른쪽 회색선: 해당 요청에 대한 메인 스레드의 작업 시간 
3. Framee: 화면의 변화가 있을 때마다 스크린샷을 찍어줌
4. Timings: 리액트에서 각 컴포넌트의 렌더링 시간을 측정함. 
5. Main: 브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트로 보여줌
6. 하단 
   - Summary: 선택 영역에서 발생한 작업 시간의 총합과 각 작업이 차지하는 비중
   - Bottom-up: 가장 최하위에 있는 작업부터 상위 작업까지 역순으로 보여줌
   - Call-tree: 가장 상위 작업부터 하위 작업 순으로 작업 내용을 트리뷰로 보여줌 
   - Event log: 발생한 이빈트를 보여줌. Loading, Experience Scripting, Rendering, Painting
  
> 빨간 막대로 표시된 부분의 Main과 Timings를 확인하여 어디서 병목이 발생하는지 확인한다. 하단으로 내려가면 어떤 작업이 오래걸리는지 디테일하게 확인이 가능하고, 그 부분에서 성능적으로 개선할 수 있는 점을 찾는다.